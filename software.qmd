---
title: "Toothless Candy Bucket Project"
---


# MCU Code
All MCU Code was done on SEGGER Embedded Studio (IDE) which has a C development environment with a built-in editor and debugger for J-link integration to program the MCU itself. 

## 1. Capacitive Touch Sensor Code
The code uses GPIO signals to determine when the capvalue is high by digitally reading the pin it's connected to. When that value goes high, we digitally write to another GPIO pin (PA5) that is connected electrically to an FPGA pin (P47). Thus being able to tell the Servo Motor and LEDs to trigger when the signal goes high and additionally playing the theme song on the DFP player.

This is done within an FSM under state "STATE_WAIT_FOR_CAP" so that after the head opens up we can move to state "STATE_IR_MODE" where we no longer look for signals from the capacitive touch sensor until Toothless is reset for a new user. 

One of the main difficulties with this sensor was integrating it mechanically as it had to be detectable through the 3D printed PLA that we used for Toothless.

## 2. IR Proximity Sensor Code
The IR Proximity Sensor produces a voltage when a hand comes near the IR LED which sends a signal to a GPIO pin (PA0) for the Analog-to-Digital Converter to read on the MCU. 

The ADC was intialized in file "STM32L432KC_ADC.c" where the clock and prescaler are set and the ADC is calibrated for recieving signals. The function readADC() then reads off the value through the ADC where it's called on in the handdetection() function.

In the handdetection() function the ADC signal from the IR Proximity sensor is compared against a value we set called HIGH_THRESHOLD. If the value we receive is above that threshold we determine a hand is being detected and return a digital high, otherwise it stays low. The HIGH_THRESHOLD value was determined through trial and error from testing how close the hand had to be to trigger as well as the candy we filled the bowl with. It needed to not activate from the bottom of Toothless' head when he came down to bite each user otherwise the IR would constantly be detecting in an endless loop. 

Once the Capacitive Touch Sensor was triggered we moved to a new FSM state called "STATE_IR_MODE" where we are checking if the irvalue (from handdetection() function) is high, in which case it's written to an FPGA pin to trigger the servo motor and LEDs and the ROAR sound is played on the DFP player.

## 3. DFPlayer Mini Code
The DFPlayer was encoded entirely on the MCU interfacting with the Capacitive Touch Sensor and IR Proximity Sensor to know when to play the Theme song and ROAR, respectively.  

The DFPlayer used UART (Universal Asynchronous Receiver/Transmitter) for serial communication in order to play mp3 files from the TF card connected on it's hardware. The code used a standard baud rate of 9600 as specified on the datasheet for the USART1 register and a rate of 115200 for debugging on the USART2 register. 

Two USART addresses are established in tow pointer variables dfp_usart and dbg_usart. Based on the datasheet the DFPlayer recieves a 10-byte frame which is split up in the function DFP_SendCommand() where we're able to change the bits for the command, feedback, parameter high byte, parameter low byte, checksum high, and checksum low.

Since we didn't want any feedback we set that byte to 00 for no reply. The parameters where split to keep the full 16 bits between the high and low bytes. 

Other functions such as DFP_Play(), DFP_Pause(), and more would call on DFP_SendCommand() to complete different functions. On the datasheet it identified different addresses associated with different commands such as 0x06 to specify volume, OxOE to pause the song, OxOF to play a specific file on the TF and many more. 

For more details on specific commands, this is the datasheet we referenced:

[DFPlayer Mini Datasheet with UART Instructions](https://picaxe.com/docs/spe033.pdf)

Then in the while loop, if the Capacitive Touch Sensor is high then after the FPGA signal is sent, the DFP_PlayFolderTrack() function is called to play the theme song Test Drive that's labeled 001.mp3 in the 01 folder in the TF card. 

Similarly when the IR Proximity Sensor is high then after the FPGA signal is sent then the Roar sound on the 002.mp3 file is played. 

# FPGA Code
All FPGA Code (and testbenches) was done on Lattice Raidant which uses Hremardware Description Languages, in this case System Verilog. The software is able to synthesize and then use the Radiant Programmer tool to program the FPGA itself.

# Overall Block Diagram
The complete block diagram can be found below:

![Complete Block Diagram for FPGA. Note all wires with the sane name are connected (e.g. int_osc and reset are shared across all modules)](images/CompleteBlockDiagram.jpg)

## 1. Servo Motor Code
The Servo Motor was coded through a few different modules with various FSMs (Finite State Machines). In the file angledecoder the servo motor takes in those signals from the sensors via variables captouch and irblock to know what angle to set. When the Capacitive Touch Sensor is triggered the angle needed to be set so that the head was fully open and for the IR Proximity sensor the head needed to be set to an angle that makes it feel like the users' hand is being bitten. 

So in this FSM there are three states CLOSED, OPENED, and SLIGHT. In the next state logic we start in the CLOSED state and then when the Capacitive Touch sensor goes high, the next state is OPENED and then it toggles between the OPENED and SLIGHT states depending on the IR Proximity Sensor. It only goes back to the CLOSED state if the estop is triggered. 

For output logic, each state was set to different angles. In the CLOSED state the angle is set to 8'd30 for 30 degrees. In the OPENED state it was set to 8'd150 for 150 degrees. In the SLIGHT state the angle is set to 8'd90 for 90 degrees. These aren't the exact angles we ended up using but they are used to differentiate between the different states in the pwmgen. 

Then goes to the pwmgen module that takes in the clock from the HSOSC (High Speed Oscillator) as well as the angle for each of the respective states. In this module there's another FSM that based on the value of the angle (i.e 8'd30, 8'd150 or 8'd90) the counter is set to be different values to send different length pulses to the servo motor to move it to various angles depending on the state from angledecoder.

We used a seperate test file that only sent a pwm value via a button to test the different angles on Toothless' head. 

## 2. LED Array Code
The LED Array used SRAM (Static Rnadom-Access Memory) loaded on the bit stream to play various LED shows. The led_pattern module also used an FSM with states OFF, PLAYING, ROARING, and ON. The LED pattern was stored as an 11 bit string for the 5 white LEDs, 5 green LEDs, and 1 purple LED strip. 

When it receives a signal from captouch it goes to state PLAYING and pkays the memory of the green LEDs slowly turning on in sequence followed by the white ones and then ending with all white LEDs and the purple LED strip on. Whereas in the ROARING state it flashes the green LEDs on and off. 