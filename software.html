<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Software Programs and Design – toothless-candy-bucket</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-7e9717d9caa9b4d114d189eaeb260ada.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-9ea75ce5dbe4b9425cb3c317040c636e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-3d7c62b55d66881102b8ac37c39c15c8.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-9ea75ce5dbe4b9425cb3c317040c636e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">toothless-candy-bucket</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./materials.html"> 
<span class="menu-text">Materials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./electrical.html"> 
<span class="menu-text">Electrical Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./mechanical.html"> 
<span class="menu-text">Mechanical Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./software.html" aria-current="page"> 
<span class="menu-text">Software Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./testbenches.html"> 
<span class="menu-text">Testbenches</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./future.html"> 
<span class="menu-text">Future Work</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./references.html"> 
<span class="menu-text">References</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./members.html"> 
<span class="menu-text">People</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#mcu-code" id="toc-mcu-code" class="nav-link active" data-scroll-target="#mcu-code">MCU Code</a>
  <ul class="collapse">
  <li><a href="#capacitive-touch-sensor-code" id="toc-capacitive-touch-sensor-code" class="nav-link" data-scroll-target="#capacitive-touch-sensor-code">1. Capacitive Touch Sensor Code</a></li>
  <li><a href="#ir-proximity-sensor-code" id="toc-ir-proximity-sensor-code" class="nav-link" data-scroll-target="#ir-proximity-sensor-code">2. IR Proximity Sensor Code</a>
  <ul class="collapse">
  <li><a href="#adc-initialization-and-functions" id="toc-adc-initialization-and-functions" class="nav-link" data-scroll-target="#adc-initialization-and-functions">2.1 ADC Initialization and Functions</a></li>
  <li><a href="#hand-detection-program" id="toc-hand-detection-program" class="nav-link" data-scroll-target="#hand-detection-program">2.2 Hand Detection program</a></li>
  </ul></li>
  <li><a href="#dfplayer-mini-code" id="toc-dfplayer-mini-code" class="nav-link" data-scroll-target="#dfplayer-mini-code">3. DFPlayer Mini Code</a></li>
  </ul></li>
  <li><a href="#fpga-code" id="toc-fpga-code" class="nav-link" data-scroll-target="#fpga-code">FPGA Code</a></li>
  <li><a href="#overall-block-diagram" id="toc-overall-block-diagram" class="nav-link" data-scroll-target="#overall-block-diagram">Overall Block Diagram</a>
  <ul class="collapse">
  <li><a href="#servo-motor-code" id="toc-servo-motor-code" class="nav-link" data-scroll-target="#servo-motor-code">1. Servo Motor Code</a></li>
  <li><a href="#led-array-code" id="toc-led-array-code" class="nav-link" data-scroll-target="#led-array-code">2. LED Array Code</a></li>
  <li><a href="#synchronizer-code" id="toc-synchronizer-code" class="nav-link" data-scroll-target="#synchronizer-code">3. Synchronizer code</a></li>
  <li><a href="#clock-divider-code" id="toc-clock-divider-code" class="nav-link" data-scroll-target="#clock-divider-code">4. Clock divider code</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Software Programs and Design</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>All code can be found in the <a href="https://github.com/erinlywang?tab=repositories">Github</a> for this project.</p>
<section id="mcu-code" class="level1">
<h1>MCU Code</h1>
<p>All MCU Code was done on SEGGER Embedded Studio (IDE) which has a C development environment with a built-in editor and debugger for J-link integration to program the MCU itself.</p>
<section id="capacitive-touch-sensor-code" class="level2">
<h2 class="anchored" data-anchor-id="capacitive-touch-sensor-code">1. Capacitive Touch Sensor Code</h2>
<p>The code uses GPIO signals to determine when the <code>capvalue</code> is high by digitally reading the input pin that the capacitive touch sensor is connected to. When that value goes high, we digitally write to an output GPIO pin (PA5) that is connected electrically to an input FPGA pin (P47). Thus, the incoming capacitive signal when a user touches the nose tells the servo motor and LEDs to trigger and additionally plays the theme song on the DFP player.</p>
<p>In order to not check the capacitive signal when the jaw is open and the robot is only waiting for the IR detector to go off, we implemented a Finite State Machine (FSM) such that we wait for the capacitive signal to go high in the state <code>STATE_WAIT_FOR_CAP</code>, and then when the nose is touched and the capacitive signal toggles we move to state <code>STATE_IR_MODE"</code> where we no longer look for signals from the capacitive touch sensor until Toothless is reset for a new user.</p>
</section>
<section id="ir-proximity-sensor-code" class="level2">
<h2 class="anchored" data-anchor-id="ir-proximity-sensor-code">2. IR Proximity Sensor Code</h2>
<p>The IR Proximity Sensor produces a voltage when a hand comes near the IR LED which sends a signal to a GPIO pin (PA0) that is specifically programmed with the alternate function that interfaces with the Analog-to-Digital Converter on the MCU.</p>
<p>Once the Capacitive Touch Sensor is triggered the program moves to the next FSM state called <code>STATE_IR_MODE</code> where we are checking if the <code>irvalue</code> input (from the <code>handdetection()</code> function) is high, in which case a signal is sent to an FPGA pin (Pin 2) to trigger the servo motor and LEDs and the ROAR sound is played on the DFP player.</p>
<section id="adc-initialization-and-functions" class="level3">
<h3 class="anchored" data-anchor-id="adc-initialization-and-functions">2.1 ADC Initialization and Functions</h3>
<p>We separated the code for ADC specific functions and initialization into its own header and .C file for organization. The ADC was intialized in file <code>STM32L432KC_ADC.c</code> where the ADC clock is enabled and set as the system clock (8MHz) divided by 4 (2MHz) to run at a safe but quick speed for reading the analog signals. Because we used the <code>CKMODE</code> register to set the division, we did not need to use the prescaler for the ADC to divide the clock further. We then turned off Deep Power-Down Mode, enabled the voltage regulator, and then delayed for 20μs as per the datasheet. After delaying, the ADC could then be calibrated and configured. We used a single, right-aligned, 12-bit configuration then configured using 1 conversion at a time.</p>
<p>The function <code>readADC()</code> then starts the conversion, waits for the conversion to be finished, then reads off the value through the ADC where it’s called later on in the <code>handdetection()</code> function.</p>
</section>
<section id="hand-detection-program" class="level3">
<h3 class="anchored" data-anchor-id="hand-detection-program">2.2 Hand Detection program</h3>
<p>The <code>handdetection()</code> function calls on the <code>readADC()</code> function to read in the converted analog signal from the IR Proximity sensor as a digital value. This digital value is compared against a value we set called <code>HIGH_THRESHOLD</code> which we define in <code>main.h</code>. If the value we receive is above that threshold we determine a hand is being detected and return a digital high, otherwise it stays low. The <code>HIGH_THRESHOLD</code> value was determined through trial and error using the <code>debugger</code> tool and using a <code>printf</code> statement to visually see the incoming digital values when the the open jaw was over the sensor versus when a hand was close to the sensor. The value was chosen such that the sensor was not activated from the bottom of Toothless’ head when the jaw was open slightly or open all the way otherwise the IR would constantly be detecting in an endless loop. A delay of 2 seconds was added between sending the <code>irvalue</code> from pin PB3 to the FPGA on pin P2 and then writing PB3 back to 0 so that the MCU wasn’t checking incoming values from the IR sensor when the jaw was closing on the hand. This gave a good enough pause for the roar to play and the mouth to close and open before another object could be detected.</p>
</section>
</section>
<section id="dfplayer-mini-code" class="level2">
<h2 class="anchored" data-anchor-id="dfplayer-mini-code">3. DFPlayer Mini Code</h2>
<p>The DFPlayer was encoded entirely on the MCU interfacting with the Capacitive Touch Sensor and IR Proximity Sensor to know when to play the Theme song and ROAR, respectively.</p>
<p>The DFPlayer used UART (Universal Asynchronous Receiver/Transmitter) for serial communication in order to play mp3 files from the TF card connected on it’s hardware. The code used a standard baud rate of 9600 as specified on the datasheet for the USART1 register and a rate of 115200 for debugging on the USART2 register.</p>
<p>Two USART addresses are established in tow pointer variables dfp_usart and dbg_usart. Based on the datasheet the DFPlayer recieves a 10-byte frame which is split up in the function DFP_SendCommand() where we’re able to change the bits for the command, feedback, parameter high byte, parameter low byte, checksum high, and checksum low.</p>
<p>Since we didn’t want any feedback we set that byte to 00 for no reply. The parameters where split to keep the full 16 bits between the high and low bytes.</p>
<p>Other functions such as DFP_Play(), DFP_Pause(), and more would call on DFP_SendCommand() to complete different functions. On the datasheet it identified different addresses associated with different commands such as 0x06 to specify volume, OxOE to pause the song, OxOF to play a specific file on the TF and many more.</p>
<p>For more details on specific commands, this is the datasheet we referenced:</p>
<p><a href="https://picaxe.com/docs/spe033.pdf">DFPlayer Mini Datasheet with UART Instructions</a></p>
<p>Then in the while loop, if the Capacitive Touch Sensor is high then after the FPGA signal is sent, the DFP_PlayFolderTrack() function is called to play the theme song Test Drive that’s labeled 001.mp3 in the 01 folder in the TF card.</p>
<p>Similarly when the IR Proximity Sensor is high then after the FPGA signal is sent then the Roar sound on the 002.mp3 file is played.</p>
</section>
</section>
<section id="fpga-code" class="level1">
<h1>FPGA Code</h1>
<p>All FPGA Code (and testbenches) was done on Lattice Raidant which uses Hremardware Description Languages, in this case System Verilog. The software is able to synthesize and then use the Radiant Programmer tool to program the FPGA itself.</p>
</section>
<section id="overall-block-diagram" class="level1">
<h1>Overall Block Diagram</h1>
<p>The complete block diagram can be found below (<a href="#fig-block" class="quarto-xref">Figure&nbsp;1</a>):</p>
<div id="fig-block" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/CompleteBlockDiagram.jpg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Complete Block Diagram for FPGA. Note all wires with the sane name are connected (e.g.&nbsp;int_osc and reset are shared across all modules)
</figcaption>
</figure>
</div>
<section id="servo-motor-code" class="level2">
<h2 class="anchored" data-anchor-id="servo-motor-code">1. Servo Motor Code</h2>
<p>The Servo Motor was coded mainly through modules <code>angle_decoder</code> and <code>pwm_gen</code> to decide based on the input which angle to open the jaw to. Both modules work in conjunction to open the jaw to the right angle and hold the angle when needed. First, the inputs from the <code>estop</code> and from the MCU, including the capacitive sensor (<code>captouch</code>) and the IR detector (<code>irblock</code>), are sent through the <code>synchronizer</code> to synchronize the inputs. The synchronized inputs are then sent to the <code>angledecoder</code> module which implements an FSM to move from a <code>CLOSED</code> to an <code>OPEN</code> state and then to a <code>SLIGHT</code> state (and back and forth between the three) based on whether the capacitive sensor has been activated or the IR sensor has been activated. servo motor takes in those signals The FSM configuration allowed the angle to be set such that the head would stay fully open until the IR proximity sensor detected a hand and then for the jaw to close just enough to make it feel like the users’ hand is being bitten before returning to the <code>OPEN</code> state. The state only goes back to <code>CLOSED</code> if the estop is triggered for resetting the device for the next user.</p>
<p>For output logic, each state was set to different angles. In the CLOSED state the angle is set to 8’d30 for 30 degrees. In the OPENED state it was set to 8’d150 for 150 degrees. In the SLIGHT state the angle is set to 8’d90 for 90 degrees. These weren’t the exact angles we ended up using but were instead used to differentiate between a fully closed, fully open, and slightly open angle when sending this state to the <code>pwmgen</code> module.</p>
<p>The <code>angle_decoder</code> then sends <code>8'd30</code>, <code>8'd150</code>, or <code>8d90</code> to the <code>pwmgen</code> module corresponding to whether the mouth should be closed, open, or slightly open respectively. The servo works interestingly in that instead of a PWM signal at a certain frequency to set the angle, the servo bases the angle on the “on-time pulse width” or how long the PWM is on for. For many hobby servos, the servo motor shaft can be rotated from 0° to 180° by varying the pulse width from 1ms to 2 ms. We used a <a href="https://blog.wokwi.com/learn-servo-motor-using-wokwi-logic-analyzer/">Wokwi blog</a> to help understand how to control the servo motor. Using this information, in the <code>pwmgen</code> module the output <code>pwm</code> signal is set to toggle on for a period of time based on a counter, toggling <code>LOW</code> once a certain counter value is hit such that the pulse width is only on for that specified amount of clock cycles. The counter value that the <code>pwm</code> output toggles on depends on the <code>angle</code> output from the <code>angledecoder</code> module. In order to have the change between opening, chomping, and closing to be visible, the <code>angledecoder</code> module used the <code>clk_enable</code> signal from the <code>clk_div</code> module to slow down the speed from state to state.</p>
<p>To test what the counter values needed to be to reach our desired angles on the mechanical body, we used a seperate test file that sent a hard-coded <code>pwm</code> value to the servo and manually found which counter value matched our desired angles on Toothless’ head.</p>
</section>
<section id="led-array-code" class="level2">
<h2 class="anchored" data-anchor-id="led-array-code">2. LED Array Code</h2>
<p>The LED Array used <code>SRAM</code> (Static Rnadom-Access Memory) loaded on the FPGA’s bitstream to play various LED shows. Since SRAM is volatile, the memory resets everytime the FPGA is reset which introduced the problem of the FPGA erasing the LED show upon every boot. However, loading the pattern into the bitstream allowed us to reload in the LED show automatically everytime the FPGA resets instead of having to load in the show manually. The <code>led_pattern</code> module also used an FSM with states <code>OFF</code>, <code>PLAYING</code>, <code>ROARING</code>, and <code>ON</code>. The LED pattern was stored as an 11 bit string for the 5 white LEDs, 5 green LEDs, and 1 purple LED strip.</p>
<p>When it receives a signal from <code>captouch</code> it goes to state <code>PLAYING</code> and plays the pattern of the green LEDs, slowly turning on in sequence, followed by the white ones, and then ending by moving to the <code>ON</code> state with all white LEDs and the purple LED strip on. In the <code>ROARING</code> state the LED pattern flashes the green LEDs on and off three times before returning to the <code>ON</code> state. In order to have the change between each step of the LED sequence to be visible, the <code>led_pattern</code> used the <code>clk_enable</code> signal from the <code>clk_div</code> module to slow down the speed from state to state and step to step such that the eye could see every change clearly.</p>
</section>
<section id="synchronizer-code" class="level2">
<h2 class="anchored" data-anchor-id="synchronizer-code">3. Synchronizer code</h2>
<p>The <code>synchronizer</code> module uses two flip flops to synchronize an asynchronous input and output a synchronous signal to the rest of the modules. The module was used to synchronize the <code>captouch</code> and <code>irblock</code> inputs from the MCU and the <code>estop</code> input from the external button.</p>
</section>
<section id="clock-divider-code" class="level2">
<h2 class="anchored" data-anchor-id="clock-divider-code">4. Clock divider code</h2>
<p>The <code>clk_div</code> module uses a counter to slow the internal <code>HSOSC</code> clock down such that the changes between states for the jaw and the LEDs were visible. The module does this by sending a high pulse every 2000000 cycles such that with an internal clock of 24MHz, the states of <code>angledecoder</code> and <code>led_pattern</code> change on a 12Hz frequency.</p>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/erinlywang\.github\.io\/toothless-candy-bucket\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // default icon
            link.classList.add("external");
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>